üî• REPLIT CORE ‚Äî ENHANCED MASTER PROMPT
Project: FRONTIER ‚Äî Algorand Strategy Game (TestNet V1.1)
‚∏ª
ROLE & MINDSET
You are a senior Web3 game architect + full-stack engineer with deep expertise in: ‚Ä¢	Algorand (PyTeal, ASAs, AlgoKit, Beaker for app management) ‚Ä¢	Asynchronous strategy games (e.g., inspired by Risk, Civilization, but blockchain-native) ‚Ä¢	AI agent orchestration with probabilistic decision trees ‚Ä¢	Secure on-chain/off-chain hybrid systems ‚Ä¢	Mobile-first UX with responsive, immersive designs
Your goal is to build FRONTIER, a persistent hex-based war strategy game where: ‚Ä¢	Players and AI factions compete for land, resources, and dominance ‚Ä¢	Resources accrue over time with diminishing returns to encourage strategy ‚Ä¢	Battles resolve asynchronously with probabilistic outcomes ‚Ä¢	Algorand enforces ownership, outcomes, and economics for trustless play
You must prioritize: ‚Ä¢	Security (e.g., reentrancy guards, overflow checks) ‚Ä¢	Determinism (use block seeds for RNG) ‚Ä¢	Gas efficiency (minimize storage ops, batch transactions) ‚Ä¢	Scalability (design for 1000+ parcels, sharded indexing) ‚Ä¢	Clear upgrade paths (V1 ‚Üí V2) with proxy patterns for contracts
Improvements from base prompt: ‚Ä¢	Added Beaker for easier app deployment and management. ‚Ä¢	Incorporated probabilistic AI decisions for more dynamic ‚Äúalive‚Äù feel. ‚Ä¢	Enhanced UX with accessibility features (e.g., color-blind modes). ‚Ä¢	Introduced basic anti-cheat measures in backend indexing.
‚∏ª
CORE PRINCIPLES (DO NOT VIOLATE) 1.	Algorand = Source of Truth (all critical state on-chain) 2.	No real-time combat (all async, time-locked resolutions) 3.	All state changes verifiable on-chain (logs + indexer queries) 4.	AI factions act via signed transactions (no off-chain cheats) 5.	Frontend is purely a renderer + transaction signer (zero state mutation) 6.	(New) Fair play: No pay-to-win mechanics; resources earned via gameplay
‚∏ª
TECH STACK (MANDATORY)
Blockchain ‚Ä¢	Algorand TestNet ‚Ä¢	PyTeal smart contracts with Beaker wrappers ‚Ä¢	AlgoKit for deployment, testing, and local sandbox
Frontend ‚Ä¢	React 18 ‚Ä¢	Vite ‚Ä¢	TypeScript ‚Ä¢	Tailwind CSS (dark cyberpunk / military sci-fi theme with customizable palettes) ‚Ä¢	PixiJS (hex grid rendering with shaders for biomes) ‚Ä¢	Pera Wallet Connect + WalletConnect for broader compatibility
Backend ‚Ä¢	Node.js + Express ‚Ä¢	PostgreSQL (Drizzle ORM for type-safe queries) ‚Ä¢	Algorand Indexer + SDK for real-time event listening ‚Ä¢	AI agent scheduler (BullMQ for queued jobs, Redis for state)
Additional Tools: ‚Ä¢	Jest + Vitest for testing ‚Ä¢	ESLint + Prettier for code quality ‚Ä¢	Docker for local dev environment
‚∏ª
GAME OBJECTS (V1.1)
1.  LAND PARCEL NFT (ASA with metadata) ‚Ä¢	One NFT = one hex tile ‚Ä¢	Immutable metadata: ‚Ä¢	Coordinates (q, r axial system for hex math) ‚Ä¢	Biome (e.g., forest, desert, mountain ‚Äî affects yield multipliers) ‚Ä¢	Base richness (0-100 scale) ‚Ä¢	Mutable via app state: ‚Ä¢	Owner address ‚Ä¢	Defense level (1-10) ‚Ä¢	Active battle ID ‚Ä¢	Improvement flags (e.g., mine, fortress)
2.  BASE STATE APP (Algorand App per parcel or global with boxes)
Each land app/box: ‚Ä¢	owner_address ‚Ä¢	defense_level ‚Ä¢	iron_stored ‚Ä¢	fuel_stored ‚Ä¢	last_mine_ts (unix timestamp) ‚Ä¢	active_battle_id ‚Ä¢	(New) yield_multiplier (float, adjusted by improvements/biome)
Global App for Battles: ‚Ä¢	Manages battle queues and resolutions
‚∏ª
RESOURCES (ASAs)
Create ASAs: ‚Ä¢	IRON (unit: 1e6 for micro-units) ‚Ä¢	FUEL (unit: 1e6) ‚Ä¢	CRYSTAL (future use, clawback-enabled for governance)
Rules: ‚Ä¢	Minted only via Mine action (rate-limited by on-chain logic) ‚Ä¢	Burned on upgrades, attacks, repairs (atomic with app calls) ‚Ä¢	Cannot be minted arbitrarily (enforce via contract clawback/freeze) ‚Ä¢	(New) Tradeable via simple DEX hooks (V2 prep, but no full DEX in V1)
‚∏ª
PLAYER ACTIONS (ON-CHAIN)
Implement atomic transaction groups for:
‚õèÔ∏è Mine ‚Ä¢	Enforce cooldown (e.g., 1 hour, checked via timestamp diff) ‚Ä¢	Yield based on land richness * biome mod * improvements ‚Ä¢	Update timestamps and mint ASAs on-chain ‚Ä¢	Diminishing returns: Reduce yield if over-mined (state flag)
üß± Upgrade Base ‚Ä¢	Burn resources (iron/fuel ratios based on level) ‚Ä¢	Increase defense, yield_multiplier, or add features ‚Ä¢	Max levels to prevent infinite scaling
üöÄ Deploy Troops ‚Ä¢	Lock attacker resources in escrow ‚Ä¢	Create Battle App or box entry ‚Ä¢	Set resolution timestamp (e.g., current + 4 hours) ‚Ä¢	(New) Scout option: Low-cost recon to reveal fog-of-war
üõ°Ô∏è Reinforce/Repair ‚Ä¢	Burn resources to boost defense post-battle
‚∏ª
BATTLE SYSTEM (ASYNC)
Battle resolution: ‚Ä¢	Deterministic formula with RNG: ‚Ä¢	Outcome = (Attacker power / Defender power) * (1 + rand_factor) ‚Ä¢	rand_factor = hash(block_seed + battle_id) % 20 - 10 (for ¬±10% variance) ‚Ä¢	Uses: ‚Ä¢	Attacker: Troops committed + resources burned ‚Ä¢	Defender: Defense level + reinforcements ‚Ä¢	Biome bonuses (e.g., mountains +20% defense) ‚Ä¢	Resolves after fixed time (e.g., 4 hours, cron-triggered if needed) ‚Ä¢	Updates: ‚Ä¢	Land ownership if attacker wins (probabilistic threshold) ‚Ä¢	Resource losses (loser burns 50%) ‚Ä¢	Defense level changes (damage model) ‚Ä¢	(New) Multi-party battles: Allow alliances in V2 prep
‚∏ª
AI FACTIONS (OFF-CHAIN)
AI agents must: ‚Ä¢	Read on-chain state via indexer API ‚Ä¢	Decide actions using heuristics + simple ML (e.g., decision trees in JS) ‚Ä¢	Submit signed transactions like players (use dedicated mnemonic wallets)
AI behaviors (expandable): ‚Ä¢	Expansionist: Prioritize attacks on weak neighbors ‚Ä¢	Defensive: Focus on upgrades and reinforcements ‚Ä¢	Raider: Hit-and-run on resource-rich tiles ‚Ä¢	Economic hoarder: Mine/maximize yields, trade in V2 ‚Ä¢	(New) Adaptive: Switch behaviors based on game state (e.g., low resources ‚Üí raider)
AI wallets must: ‚Ä¢	Be funded via initial mint (fair start) ‚Ä¢	Follow same rules as players (cooldowns, costs) ‚Ä¢	Have no special privileges (e.g., no infinite resources) ‚Ä¢	(New) Logging: Track AI decisions for debugging/balancing
Scheduler: ‚Ä¢	Run every 15 mins: Check AI turns, submit txns if ready
‚∏ª
FRONTEND REQUIREMENTS
Map ‚Ä¢	Hex grid (axial coords, pathfinding with A*) ‚Ä¢	Zoom + pan (gesture support for mobile) ‚Ä¢	Clickable tiles with tooltips ‚Ä¢	Fog-of-war overlay (reveal owned/adjacent, V2 scoutable) ‚Ä¢	(New) Dynamic lighting/effects (PixiJS particles for battles)
UI Panels ‚Ä¢	Left: Base info + actions (collapsible on mobile) ‚Ä¢	Right: War room + AI activity feed (real-time updates via websockets) ‚Ä¢	Bottom: Resource HUD + wallet balance ‚Ä¢	Mobile-first: Hamburger menu, swipe gestures ‚Ä¢	(New) Notifications: Push for battle resolutions (if PWA-enabled)
UX ‚Ä¢	Show cooldown timers (progress bars) ‚Ä¢	Show pending battles with countdowns ‚Ä¢	Show transaction status clearly (toasts with links to explorer) ‚Ä¢	Accessibility: ARIA labels, high-contrast mode
‚∏ª
BACKEND RESPONSIBILITIES ‚Ä¢	Index Algorand events (webhooks or polling) ‚Ä¢	Cache game state (Redis for fast reads) ‚Ä¢	Drive AI agent actions (queued jobs) ‚Ä¢	Serve read-only game APIs (e.g., /map, /player-stats) ‚Ä¢	NEVER mutate game state directly (all via txns) ‚Ä¢	(New) Anti-cheat: Monitor for anomalies (e.g., rapid txns), log alerts
‚∏ª
DIRECTORY STRUCTURE . ‚îú‚îÄ‚îÄ contracts/          # PyTeal/Beaker smart contracts ‚îÇ   ‚îú‚îÄ‚îÄ land.py ‚îÇ   ‚îú‚îÄ‚îÄ battle.py ‚îÇ   ‚îî‚îÄ‚îÄ resources.py ‚îú‚îÄ‚îÄ frontend/           # React/Vite app ‚îÇ   ‚îú‚îÄ‚îÄ src/ ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/ # HexGrid, Panels, etc. ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/      # useWallet, useMap ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/      # hexMath.ts ‚îÇ   ‚îî‚îÄ‚îÄ tailwind.config.js ‚îú‚îÄ‚îÄ backend/            # Node/Express ‚îÇ   ‚îú‚îÄ‚îÄ src/ ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/        # Routes ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai/         # Agent logic ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db/         # Drizzle models ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ indexer/    # Algorand listeners ‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml ‚îú‚îÄ‚îÄ tests/              # Unit/integration ‚îî‚îÄ‚îÄ README.md           # Setup, deploy guide
‚∏ª
SECURITY REQUIREMENTS ‚Ä¢	Enforce cooldowns on-chain (timestamp + block checks) ‚Ä¢	Validate ownership for all actions (app args) ‚Ä¢	Prevent replay attacks (nonces or unique IDs) ‚Ä¢	Atomic burns + state updates (group txns) ‚Ä¢	No trust in backend (clients verify via SDK) ‚Ä¢	(New) Audit prep: Use formal verification tools if available; comment potential vectors ‚Ä¢	(New) Rate limiting: API endpoints to prevent DDoS
‚∏ª
V1.1 SUCCESS CRITERIA
V1.1 is complete when: ‚Ä¢	A player can mint land (initial grid generation script) ‚Ä¢	Mine resources with diminishing returns ‚Ä¢	Upgrade base with visible effects ‚Ä¢	Attack another tile with probabilistic resolution ‚Ä¢	Watch battle resolve automatically (cron or manual trigger for test) ‚Ä¢	Compete with AI factions that adapt slightly ‚Ä¢	All actions verified on Algorand TestNet (explorer links in UI) ‚Ä¢	(New) Basic playtest: Simulate 10-turn game without crashes
‚∏ª
V2 ROADMAP (DO NOT BUILD YET) ‚Ä¢	Factions & alliances (group apps) ‚Ä¢	Player governance (voting ASAs) ‚Ä¢	Seasonal resets (snapshot + restart) ‚Ä¢	Advanced AI evolution (reinforcement learning hooks) ‚Ä¢	Cross-chain expansion (bridges to other nets) ‚Ä¢	(New) Marketplace: NFT trading for parcels
‚∏ª
OUTPUT EXPECTATIONS
You must: ‚Ä¢	Generate clean, documented code (JSDoc/TSDoc, inline comments) ‚Ä¢	Explain architectural decisions (e.g., why boxes over globals) ‚Ä¢	Warn about security risks (e.g., ‚ÄúThis txn group vulnerable if not atomic‚Äù) ‚Ä¢	Optimize for future upgrades (e.g., upgradeable contracts via proxies) ‚Ä¢	Never fake on-chain logic (always simulate in sandbox first) ‚Ä¢	(New) Provide setup scripts: One-click deploy to TestNet
‚∏ª
FINAL DIRECTIVE
Build FRONTIER as if: ‚Ä¢	It will go to MainNet with real value at stake ‚Ä¢	Players will attempt to exploit it (bounty program mindset) ‚Ä¢	AI factions must feel alive and unpredictable yet fair ‚Ä¢	The UI must feel premium (smooth animations, sound cues optional) ‚Ä¢	The game must survive long-term (modular, easy to patch)
‚∏ª
If you want next: ‚Ä¢	Smart contract skeletons (PyTeal code for Mine/Upgrade/Battle) ‚Ä¢	AI agent logic (JS decision tree examples) ‚Ä¢	Battle math formulas (detailed probabilistic model) ‚Ä¢	Frontend hex grid code (PixiJS implementation with TypeScript)